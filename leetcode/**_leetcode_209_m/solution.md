# 长度最小的子数组
这道题是一道很经典的滑动窗口问题，需要很好的掌握。
## Solution 1 暴力求解法
第一时间想到了循环查询长度[1, n]的窗口进行求和之后比较，得出最短的长度返回，但是这样就出现了问题: 操作时间复杂度是O(n^2)，在力扣更新了数据之后，暴力求解法100%超过时间复杂度。

## Solution 2 滑动窗口法
该解法是学习了`@代码随想录`的视频之后学习到的，滑动窗口的最主要思想是维护头指针和尾指针，并且合理控制窗口指针的移动。  
最开始的思路是头指针指向首部，尾指针指向尾部，求和比较厚滑动头指针向后，但貌似这和`Solution 1`并没有本质上的区别。  
`@代码随想录`的思想如下
1. 维护尾指针于起始位置(j = 0)，头指针依然为起始位置(i = 0)
2. 累积尾指针的值(sum += nums[j])
3. 累积和大于target之后，记录区间大小(如果小于已有记录)，减去头指针的值，并且移动头指针，缩小窗口size (sum -= nums[i]; i += 1)
4. 循环操作3直至累积和小于target (for sum >= target)
5. 移动尾指针，如果尾指针小于数组长度，回到操作2 (j += 1; j < len(nums)
显而易见的是，这个算法仅仅将数组遍历了一遍，便完成了对整个数组的一个遍历，时间复杂度降至了O(n)
![img.png](img.png)  

参考链接: https://www.bilibili.com/video/BV1tZ4y1q7XE/?spm_id_from=333.788&vd_source=9c364d9aa07f4d54211f586cd1257691