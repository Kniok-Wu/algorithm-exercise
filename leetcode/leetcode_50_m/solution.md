# Pow(x, n) 问题


## 1. 朴素方法
即循环实现n次x相乘，时间复杂度为o(N)，当n巨大时，耗时同样巨大。

## 2. 快速幂乘法
假设 n 为 4，那么 Pow(x, 4) 可以演化为:
<center>x^4 = x^2 * x^2</center>
由此我们可以知道，利用积累型，我们可以将 4 次 x 相乘，转化为一个 Pow(Pow(x, 2), 2)，变为 2 次计算，时间复杂度为 O(log_n)。
上述时 n 为偶数的情况，当 n 为奇数时呢，假设 n 为105:  

> 2^105 -> 2^57(+) -> 2^28(+) -> 2^14 -> 2^7 -> 2^3(+) -> 2^1(+)

其中，(+)表示需要单独乘以x。因此，我们的代码逻辑基本浮出水面。
```go
for n > 0 {
	if n % 2 == 1 {
		res *= x
	}
	
	x *= x
	
	n /= 2
}
```
其实从二进制的角度，能更好地理解这个问题，推荐链接:  
https://www.bilibili.com/video/BV16Z4y1M7y1/  
这个链接讲的十分简洁明了，推荐学习。
