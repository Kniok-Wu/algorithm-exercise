# 1. 暴力解法
由于已知字符串可能由重复子串构成，因此指针i从1-n/2为止，因为既然要求为子串重复，那么至少为一个子串两次构成。  
因此使用两层for循环遍历所有子串进行对比即可。推得在这种算法下，时间复杂度在最差的情况下为O(n^2)。  

![img.png](img.png)

貌似也挺快的。  

# 2. 移动匹配法  
即如果s由重复子串构成，那么假设`ss = s + s`，同时去掉头尾(如果不去掉头尾，那么一定能找到原来的s)，那么一定能搜索到对应的s。
```go
s := "abcabcabc"
ss := s + s // "abcabcabcabcabcabc"
ss = ss[1:len(ss)-1] // "bcabcabcabcabcab"
```  
然后就是 `KMP算法` 了，KMP算法是一个必会的算法，他的设计构思都很巧妙。  
要理解KMP算法，首先要理解KMP算法的执行逻辑。传统的匹配算法是两层for循环，依次对原字符串和目标字符串进行匹配，那么很容易计算时间复杂度为O(m * n)。KMP的改进思路是当每次我们匹配失败之后，我们之前匹配过的部分我们是否可以利用起来，加速匹配过程。  
因此，KMP利用了一个前缀数组，即求的子串中以第一个字符开始，到任意字符结束，他的前缀和后缀相同的字符个数。  

## 2.1 前缀/后缀
首先需要了解前缀/和后缀是什么，假设存在一个字符串"asdacasd"，那么他的前缀是除了末尾的'd'以外，前部的1~n-1个字符组成的子串:"a"、"as"、"asd"、....、"asdacas"。后缀同理，为除了首位'a'以外，后部2～n个字符组成的子串。  

## 2.2 前缀数组  
知道了前缀/后缀的概念，为什么要求前缀数组呢？假设一个字符串为"aabaabaabaaf"，需要匹配的子串为"aabaaf"，当i = 5时，匹配到 'b' != 'f'，如果按照传统方法，此时回退到 i = 1，继续下一次搜索。  
但是我们此时知道，前部分不论怎么都无法完全符合，但是失败的'b'与前两个字母组成的'aab'是匹配的，因此如何利用这个'aa'呢，这时候就用到了前缀。  
> a a b a a f
> 0 0 1 0 1 2  

根据2.1中的概念，我们可以很容易得到这么一个前缀数组，那么当我们匹配到'f'时，我们知道子串起始两个字符'aa'和'f'的前两个字符是相同的，那么我们就可以跳过这两个字符，减少匹配次数，其余字符同理。这就是KMP的和新思路，KMP算法的时间复杂度为O(m + n)，空间复杂度为O(n)，n为子串长度，m为待匹配字符串长度。  
